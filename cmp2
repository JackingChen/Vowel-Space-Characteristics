def FilterUttDictsByCriterion_map(self,Formants_utt_symb,Formants_utt_symb_cmp,keys,limit_people_rule):
        # Masks will be generated by setting criterion on Formants_utt_symb
        # and Formants_utt_symb_cmp will be masked by the same mask as Formants_utt_symb
        # we need to make sure two things:
        #   1. the length of Formants_utt_symb_cmp and Formants_utt_symb are the same
        #   2. the phone sequences are aligned correctly
        #The logic of this function is originated from alignment-human comparison and shared by the IQR filtering case
        Formants_utt_symb_limited=Dict()
        Formants_utt_symb_cmp_limited=Dict()
        for utt in tqdm(keys):
            people=utt[:utt.find(re.findall("_[K|D]",utt)[0])]
            df_ori=Formants_utt_symb[utt].sort_values(by="start")
            df_cmp=Formants_utt_symb_cmp[utt].sort_values(by="start")
            df_ori['text']=df_ori.index
            df_cmp['text']=df_cmp.index
            
            r=df_cmp.index.astype(str)
            h=df_ori.index.astype(str)
            
            error_info, WER_value=WER(r,h)
            utt_human_ali, utt_hype_ali=Get_aligned_sequences(ref=df_cmp, hype=df_ori ,error_info=error_info) # This step cannot gaurentee hype and human be exact the same string
                                                                                                              # because substitude error also counts when selecting the optimal 
                                                                                                              # matched string         
            utt_human_ali.index=utt_human_ali['text']
            utt_human_ali=utt_human_ali.drop(columns=["text"])
            utt_hype_ali.index=utt_hype_ali['text']
            utt_hype_ali=utt_hype_ali.drop(columns=["text"])
            
            assert len(utt_human_ali) == len(utt_hype_ali)
            limit_rule=limit_people_rule[people]
            SymbRuleChecked_bookkeep={}
            for symb_P in limit_rule.keys():
                values_limit=limit_rule[symb_P]
        
                filter_bool=utt_hype_ali.index.str.contains(symb_P)  #  1. select the phone with criterion
                filter_bool_inv=np.invert(filter_bool)           #  2. create a mask for unchoosed phones
                                                                 #  we want to make sure that only 
                                                                 #  the phones not match the criterion will be False
                for feat in values_limit.keys():
                    feat_max_value=values_limit[feat]['max']
                    filter_bool=np.logical_and(filter_bool , (utt_hype_ali[feat]<=feat_max_value))
                    feat_min_value=values_limit[feat]['min']
                    filter_bool=np.logical_and(filter_bool , (utt_hype_ali[feat]>=feat_min_value))
                    
                filter_bool=np.logical_or(filter_bool_inv,filter_bool)
                
                # check & debug
                if not filter_bool.all():
                    print(utt,filter_bool[filter_bool==False])
                
                SymbRuleChecked_bookkeep[symb_P]=filter_bool.to_frame()
            
            df_True=pd.DataFrame(np.array([True]*len(utt_hype_ali)))
            for keys, values in SymbRuleChecked_bookkeep.items():
                df_True=np.logical_and(values,df_True)
            
            Formants_utt_symb_limited[utt]=utt_hype_ali[df_True[0].values]
            Formants_utt_symb_cmp_limited[utt]=utt_human_ali[df_True[0].values]
        return Formants_utt_symb_limited,Formants_utt_symb_cmp_limited